

## A

本来做 188股票买卖问题4，但是递归各种超时，所以又翻回去找 123股票买卖问题3的其他解法，希望从中得到启发，于是get到了 leetcode123的另外两种解法。

- [原题：leetcode.123.股票买卖问题3]
解法1：
```java
// https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/
// 123.买卖股票的最佳时机3
class Solution {
    public int maxProfit(int[] prices) {
        
        // 1. 数组为空，或只有一个元素，则最大利润为0
        if(prices.length<=1){
            return 0;
        }
        
        int totalMaxProfit = 0;
        
        // 2. 以i分割数组，分别求左边和右边各做一笔交易的最大利润，求和。并保存最大的和，即为全局最大利润
        for(int i=1;i<prices.length;i++){
            // 左侧闭区间：[0,i]
            // 右侧闭区间：[i+1,length-1]
            int leftMaxProfit = maxProfit(prices,0,i);
            int rightMaxProfit = maxProfit(prices,i+1,prices.length-1);
            if(leftMaxProfit+rightMaxProfit >totalMaxProfit){
                totalMaxProfit = leftMaxProfit+rightMaxProfit;
            }
        }
        
        return totalMaxProfit;
    }
    
    
    // 求闭区间 [from,to] 做一笔交易的最大值。
    int maxProfit(int[] prices,int from,int to){
        if(from>=to){
            return 0;
        }
        if(from+1==to){
            return prices[to]-prices[from]>0?prices[to]-prices[from]:0;
        }
        
        int minPrice = prices[from];
        int maxProfit = 0;
        for(int i=from+1;i<prices.length && i<=to;i++){
            // 若今天价格高于前面几天的最低价格，则可以卖出。
            // 此时，计算今天卖出利润多少，是否比已计算的利润更高
            if(prices[i]>minPrice && maxProfit<(prices[i]-minPrice)){
                maxProfit = prices[i]-minPrice;
            }
            
            // 若今天价格低于前几天的最低价格，则更新最低价格
            if(prices[i]<minPrice){
                minPrice = prices[i];
            }
        }
        
        return maxProfit;
    }
}
```

解法2：
```java
// https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/
// 123.买卖股票的最佳时机3
class Solution {
    public int maxProfit(int[] prices) {
        
        // 1. 数组为空，或只有一个元素，则最大利润为0
        if(prices.length<=1){
            return 0;
        }
        
        // 从左往右，计算只做一次交易的最大利润
        int[] dpLeft = new int[prices.length];
        int minPrice = prices[0];
        for(int i=1;i<prices.length;i++){
            dpLeft[i] = Math.max(dpLeft[i-1],prices[i]-minPrice);
            minPrice = Math.min(minPrice,prices[i]);
        }
        
        // 从右往左，计算只做一次交易的最大利润
        int[] dpRight = new int[prices.length];
        int maxPrice = prices[prices.length-1];
        for(int i = prices.length-2;i>=0;i--){
            dpRight[i] = Math.max(dpRight[i+1],maxPrice-prices[i]);
            maxPrice = Math.max(maxPrice,prices[i]);
        }
        
        // 两个数组求和，和最大的就是最大利润
        int maxProfit = 0;
        for(int i=0;i<prices.length;i++){
            maxProfit = Math.max(maxProfit,dpLeft[i]+dpRight[i]);
        }
        
        
        return maxProfit;
    }
    
    
}
```

解法3：
```java
// https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii/
// 123.买卖股票的最佳时机3
class Solution {
    public int maxProfit(int[] prices) {
        
        // 1. 数组为空，或只有一个元素，则最大利润为0
        if(prices.length<=1){
            return 0;
        }
        
        // 2. 第 i 天时
        int firstBuyProfit = -prices[0];  // 从0到i，买入1次，可获得的最大利润。一定为负。
        int firstSellProfit = 0;          // 从0到i，卖出1次，可获得的最大利润
        int secondBuyProfit = -prices[0]; // 从0到i，买入2次，可获得的最大利润
        int secondSellProfit = 0;         // 从0到i，卖出2次，可获得的最大利润
        
        for(int i=0;i<prices.length;i++){
            // 从0到i买入1次可获得的最大利润 = max(从0到i-1买入1次可获得的最大利润，当天第1次买入可获得的最大利润 );
            firstBuyProfit = Math.max(firstBuyProfit,0-prices[i]);
            
            // 从0到i卖出1次可获得的最大利润 = max(从0到i-1卖出1次可获得的最大利润，当天第1次卖出可获得的最大利润);
            // 其中，当天第1次卖出可获得的最大利润 = 从0到i买入1次可获得的最大利润 + 当天价格。
            firstSellProfit = Math.max(firstSellProfit,firstBuyProfit+prices[i]);
            
            // 从0到i买入2次可获得的最大利润 = max(从0到i-1买入2次可获得的最大利润，当天第2次买入可获得的最大利润);
            // 其中，当天第2次卖出可获得的最大利润 = 从0到i卖出1次可获得的最大利润 - 当天价格。
            secondBuyProfit = Math.max(secondBuyProfit,firstSellProfit-prices[i]);
            
            // 从0到i卖出2次可获得的最大利润 = max(从0到i-1卖出2次可获得的最大利润，当天第2次卖出可获得的最大利润);
            // 其中，当天第2次卖出可获得的最大利润 = 从0到i买入2次可获得的最大利润 + 当天价格。
            secondSellProfit = Math.max(secondSellProfit,secondBuyProfit+prices[i]);
        }
        
        return secondSellProfit;
    }
    
    
}
```


## R


## T



## S

