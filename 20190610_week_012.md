

## A

本周做了两道题。

- [leetcode.15.三数之和](https://leetcode-cn.com/problems/3sum/submissions/)

```java
// https://leetcode-cn.com/problems/3sum/submissions/
// 15.三数之和
// 解法：三指针。需要特别注意去重逻辑。
class Solution {
    public List<List<Integer>> threeSum(int[] nums) {
        List<List<Integer>> result = new ArrayList();
        
        // 1. 先排序
        Arrays.sort(nums);
        
        // 2. 特殊处理，以下情况无解:
        //    - 数组元素不足3个
        //    - 第一个元素 >0
        //    - 最后一个元素 <0
        int len = nums.length;
        if( len<3 || nums[0]>0 || nums[len-1]<0){
            return result;
        }
        
        // 3. 特殊处理，全0则直接返回结果
        if(nums[0]==0 && nums[len-1]==0){
            List<Integer> tmp = Arrays.asList(0,0,0);
            result.add(tmp);
            return result;
        }
        
        // 4. 从头开始遍历
        for(int i=0;i<len-1;i++){
            int current = nums[i];
            // 若第一个数字>0，则不会再有解了，直接中断整个循环。
            if(current>0){
                break;
            }
            // 去重。当前节点==左边的节点
            if(i>0 && current==nums[i-1]){
                continue;
            }
            // 从 current 右边的部分，用左右指针找另外两个数字
            int left = i+1;
            int right = len-1;
            while(left<right){
                if(current + nums[left] + nums[right] >0){
                    // 若和>0，则右边的太大了，左移一位
                    while(left < right && nums[right-1] == nums[right]) right--;
                    right--;
                }else if(current + nums[left] + nums[right] <0){
                    while(left < right && nums[left+1] == nums[left]) left++;
                    // 若和<0，则左边的太小了，右移一位
                    left++;
                }else{
                    // 若和=0，则得到一个解
                    // 左右指针分别往中间移动一位
                    List<Integer> sol = new ArrayList();
                    sol.add(current);
                    sol.add(nums[left]);
                    sol.add(nums[right]);
                    result.add(sol);
                    while(left < right && nums[right-1] == nums[right]) right--;
                    while(left < right && nums[left+1] == nums[left]) left++;
                    right--;
                    left++;
                }
            }
        }
        
        return result;
    }
}
```



- [leetcode.70.爬楼梯](https://leetcode-cn.com/problems/climbing-stairs/)

- 70.解法1：
  
```java
// https://leetcode-cn.com/problems/climbing-stairs/
// 70. 爬楼梯
// 解法1：递归+哈希优化
// PS：完全递归会超时
class Solution {
    private static Map<Integer,Integer> map;
    
    public int climbStairs(int n) {
        map = new HashMap();
        return climbStairsRecursive(n);
    }
        
    public int climbStairsRecursive(int n) {
        if(n<=1){
            return 1;
        }
        int first = (null==map.get(n-1)) ? climbStairsRecursive(n-1) : map.get(n-1);
        int second = (null==map.get(n-2)) ? climbStairsRecursive(n-2) : map.get(n-2);
        int sum = first+second;
        map.put(n,sum);
        return sum;
    }
}
```


- 70.解法2：

```java
// https://leetcode-cn.com/problems/climbing-stairs/
// 70. 爬楼梯
// 解法2：非递归。
// 方程：climb[n] = climb[n-1] + climb[n-2]
// 出口：climb[0] = climb[1] = 1
class Solution {
    public int climbStairs(int n) {
        int[] arr = new int[n+2];
        arr[0]=1;
        arr[1]=1;
        
        for(int i=2;i<=n;i++){
            arr[i] = arr[i-1]+arr[i-2];
        }
        return arr[n];
    }
}
```


## R

## T

记一下最近做的新项目碰到的一个问题。

有一个业务场景，是“工作日”触发特定业务逻辑。

所以需要一个：“给定日期，判断是否为工作日的能力”。

很遗憾，没有找到能够提供这项能力的工具。




## S

想了解一下 MyBatis 底层实现原理，看到一篇不错的文章，手写实现 mini MyBatis。

感觉这才是彻底理解底层原理的正确打开方式，学习了。

传送门：[透彻理解MyBatis设计思想之手写实现](https://www.jianshu.com/p/73ee8caddc68?open_source=weibo_search)
