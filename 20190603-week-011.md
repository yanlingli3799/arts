
## A
[653.两数之和4输入BST](https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/)

```java
// 653. 两数之和 IV - 输入 BST
// https://leetcode-cn.com/problems/two-sum-iv-input-is-a-bst/submissions/
// 解法1：转化为有序列表后再处理
/**
 * Definition for a binary tree node.
 * public class TreeNode {
 *     int val;
 *     TreeNode left;
 *     TreeNode right;
 *     TreeNode(int x) { val = x; }
 * }
 */
class Solution {
        

    public boolean findTarget(TreeNode root, int target) {
        
        // 1. 特殊处理：root 为 null 则 false
        if(root == null){
            return false;
        }
        
        // 2. 遍历扔到列表里面：元素从小到大有序
        List<Integer> list = new ArrayList();
        toList(root,list);
        
        // 3. 特殊处理：不足两个元素，false
        if(list.size() <=1){
            return false;
        }
        
        int len = list.size();
        
        // 4. 特殊处理：
        //    - 最小的两个元素相加 > target，false
        //    - 最大的两个元素相加 < target，false
        if((list.get(len-1)+list.get(len-2))<target
           || (list.get(0)+list.get(1))>target){
            return false;
        }
        
        // 5. 遍历列表，查找是否有符合条件的。用 map 结合 数组有序的特性做一些简单的优化
        Map<Integer,Boolean> map = new HashMap();
        for(int i=0;i<len;i++){
            int current = list.get(i);
            int another = target-current;
            // 如果另一个比当前元素小，则去map里找。否则在map里一定找不到的
            if(another<current){
                if(map.get(another)!=null){
                    return true;
                }
            }
            map.put(current,true);
        }
        return false;    
    }
    
    
    // 树转为列表。左-根-右，这样输出的数组是有序的
    private void toList(TreeNode root,List<Integer> list){
        if(null == root){
            return;
        }
        toList(root.left,list);
        list.add(root.val);
        toList(root.right,list);        
    }
    
}
```


## R


## T

## S

