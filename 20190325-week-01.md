

前段时间正好开始重刷 leetcode 题，原计划是按顺序挨个刷的，但是到 hard 题目的时候就卡了，所以已经有几天没写算法了。

那最近看到 ARTS 挑战，感觉可以从 easy 开始刷，循序渐进慢慢来吧。




## A

Leetcode-7-Easy：

空间复杂度：O(1)
时间复杂度：O(log(x))

```java
class Solution {
    public int reverse(int x) {
        int result = 0;// 反转值
        while(x!=0){
            int left = x%10;
            if(x>0 && result > (Integer.MAX_VALUE-left)/10){
                // 如果是正数，则判断是否向上溢出
                return 0;
            }
            if(x<0 && result < (Integer.MIN_VALUE-left)/10){
                // 如果是负数，则判断是否向下溢出
                return 0;
            }
            result = result*10+left;
            x=x/10;
        }
        return result;
    }   
}
```


## R

menter 推荐的一篇文章，Robert C. Martin (Uncle Bob) 的 The Clean Architecture：[The Clean Architecture](https://blog.cleancoder.com/uncle-bob/2012/08/13/the-clean-architecture.html)

结合：[Clean simple flexible evolvable agile Architectrue](https://www.planetgeek.ch/2016/03/15/clean-simple-flexible-evolvable-agile-architecture-cheat-sheet/) 食用。




The Clean Architecture 部分翻译：
```
系统架构：
- Hexagonal Architecture
- Onion Architecture
- Screaming Architecture
- DCI
- BCE

尽管这些架构在细节上略有不同，但其实非常相似。一个共同的主题就是：分离关注点。而这种分割往往是通过划分层级实现的，至少有一个业务层，一个接口层。

每一个结构对应的系统都有以下特性：
- 独立于框架。Framework 应该是实现 Architecture 的工具，而不能把 Architecture 硬塞到有各种约束的 FrameWork 里。
- 可测试。业务规则应该是独立于 UI、数据库、Web 服务器以及其他外部因素，能够被独立测试的。
- UI 独立。UI 应该是可以被轻松修改，而不需要对系统其他部分做调整。例如：不改变业务规则的前提下，直接将网页 UI 替换为控制台 UI。
- 数据库独立。你可以将 Oracle 、SQL Server 换成 Mongo、BigTable、CouchDB 或其他数据库。你的业务逻辑不应该绑定到数据库上。
- 独立于任何外部机构。事实上，你的业务逻辑应该对外界一无所知。


The Dependency Rule：
- 同心圆代表的是软件的不同领域。一般来说，越深入，软件级别越高。外圈是物理设备，内圈是规则。
- 使这个体系结构良好运转的最重要的规则就是：依赖规则。它要求：源代码依赖只能是由外向内的，也就是依赖方向由外圈指向内圈。任意一个圈，都不应该感知到它外层的任何规则。特别是，在外圈声明的内容，都不应该被内圈使用，包括：方法、类、变量，或其他命名软件实体。
- 同样的，在外圈中使用的数据结构也不应该被内圈使用，也别是那些由外圈中的框架生成的。我们不希望外圈中的任何东西影响到内圈。


Entities：
- Entities 封装了企业业务规则。一个 Entity 可以是一个有方法的对方，也可以是一组数据结构和方法。这都不重要，只要它们能够适用于企业的多个不同应用就可以了。
- 如果你没有企业，只是写一个简单的应用，那么 entities 就是这个应用的业务对象。它们封装了最通用的高级别的业务规则。当外部规则发生了变化时，它们也几乎不会变。例如：你不会希望这些对象受到页面导航或安全性更改的影响。任意一个特定程序的操作更改都不应该影响到实体层。


Use Cases：
- 这一层包含了特定于应用程序的业务规则。它封装并实现了系统的所有用例。
- 这些用例关注实体间的数据流，并安排这些实体应用业务规则，以达到用例的目标。
- 我们希望这一层的任何改动，都不影响 Entities，同样的也不希望受到任何的外部（数据库、UI层、或者任何公共框架）更改的影响。这一层与这些关注点是隔离的。
- 但是我们确实期望对应用程序的操作更改会影响用例，进而影响到这一层中的软件。如果用例的某个细节发生了变化，那么这个层中的代码肯定会收到影响。


Interface Adapters：
- 这一层的软件是一组适配器，将数据从 Use Cases 和 Entities 使用的格式转为外层（如数据库、Web）使用的格式。
- 例如，一个完全包含 GUI 的 MVC 结构。展示层、视图、控制器都属于这里。模型可能会将数据从 controller 转到 use case，再从 use case 转到 presenters 和 views 。
- Similarly







```









## T



## S

